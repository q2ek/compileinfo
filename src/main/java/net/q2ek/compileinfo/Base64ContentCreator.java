package net.q2ek.compileinfo;

import java.io.IOException;
import java.io.Writer;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Base64.Encoder;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.Set;

/**
 * This class generates a java class source code file. It is used by
 * {@link CompileInfoAnnotationProcessor}
 *
 * @author Edze Kruizinga
 */
public class Base64ContentCreator implements ContentCreator {
	private final Writer writer;
	private final Properties properties;
	private final Encoder encoder = Base64.getEncoder();

	Base64ContentCreator(Input input) {
		this(input.writer(), input.properties());
	}

	Base64ContentCreator(Writer writer, Properties properties) {
		this.writer = writer;
		this.properties = properties;
	}

	/**
	 * @throws IOProblem
	 *             when {@link IOException} happens
	 */
	private void append(CharSequence value) {
		try {
			this.writer.append(value);
		} catch (IOException e) {
			throw new IOProblem("Could not append to writer " + this.writer + " value " + value, e);
		}
	}

	@Override
	public void write(String packageName, String name) {
		append("package " + packageName + ";\n\n");
		imports();
		classJavaDoc();
		classDeclaration(name);
		isoDateTimeConstant();
		zonedDateTimeConstant();
		writeLocalDateTime();
		writeZonedDateTime();
		writeTime();
		writePropertiesMap();
		writeProperties();
		writeKeySetMethod();
		writePropertiesMapCreater();
		putMethodCreater();
		classEnd();
	}

	private void imports() {
		append("import java.util.HashMap;\n");
		append("import java.util.Map;\n");
		append("import java.util.Set;\n");
		append("import java.time.LocalDateTime;\n");
		append("import java.time.ZonedDateTime;\n");
		append("import java.util.Base64;\n");
		append("import java.util.Base64.Decoder;\n");
		append("\n");
	}

	private void classJavaDoc() {
		append("/**\n");
		append(" * @author Generated by " + CompileInfoAnnotationProcessor.class.getCanonicalName() + "\n");
		append(" * @see " + CompileInfo.class.getSimpleName() + "\n");
		append(" */\n");
	}

	private void classDeclaration(String name) {
		append("public class " + name + "\n");
		append("{\n");
	}

	private void classEnd() {
		append("}\n");
	}

	private void isoDateTimeConstant() {
		append("    static final LocalDateTime LOCAL_DATE_TIME = LocalDateTime.parse(\"");
		append(LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
		append("\");\n");
		append("    \n");
	}

	private void zonedDateTimeConstant() {
		append("    static final ZonedDateTime ZONED_DATE_TIME = ZonedDateTime.parse(\"");
		append(ZonedDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
		append("\");\n");
		append("    \n");
	}

	private void writeLocalDateTime() {
		append("    static LocalDateTime localDateTime() {\n");
		append("        return LOCAL_DATE_TIME;\n");
		methodEnd();
	}

	private void writeZonedDateTime() {
		append("    static ZonedDateTime zonedDateTime() {\n");
		append("        return ZONED_DATE_TIME;\n");
		methodEnd();
	}

	private void writeTime() {
		append("    static String time() {\n");
		append("        return \"" + LocalDate.now() + " " + LocalTime.now() + "\";\n");
		methodEnd();
	}

	private void writePropertiesMap() {
		append("    private static final Map<String, String> properties = createMap();\n\n");
	}

	private void writePropertiesMapCreater() {
		append("    private static Map<String, String> createMap() {\n");
		append("    	Decoder decoder = Base64.getDecoder();\n");
		append("        Map<String, String> result = new HashMap<>();\n");
		List<String> keys = sortedKeys(this.properties);
		for (String key : keys) {
			putKeyValue(key);
		}
		append("        return result;\n");
		methodEnd();
	}

	private void putKeyValue(String key) {
		String value = this.properties.get(key).toString();
		String putStatementFormat = "        put(result, decoder, \"%s\", \"%s\");\n";
		String mapPutCommand = String.format(putStatementFormat, base64(key), base64(value));
		append(mapPutCommand);
	}

	private void putMethodCreater() {
		append("    private static void put(Map<String, String> result, Decoder decoder, String key, String value) {\n");
		append("    	result.put(new String(decoder.decode(key)), new String(decoder.decode(value)));\n");
		append("    }\n");
		append("    \n");
	}

	private String base64(String value) {
		return this.encoder.encodeToString(value.getBytes());
	}

	private static List<String> sortedKeys(Properties properties) {
		Set<Object> keySet = properties.keySet();
		List<String> keys = new ArrayList<>(keySet.size());
		keySet.forEach(key -> keys.add(key.toString()));
		Collections.sort(keys);
		return keys;
	}

	private void writeProperties() {
		append("    static String get(String key) {\n");
		append("        return properties.get(key);\n");
		methodEnd();
	}

	private void writeKeySetMethod() {
		append("    static Set<String> keySet() {\n");
		append("        return properties.keySet();\n");
		methodEnd();
	}

	private void methodEnd() {
		append("    }\n\n");
	}
}
